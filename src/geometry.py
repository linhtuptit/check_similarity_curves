import numpy as np 
import math


def euclidian_dist(point1, point2):
    '''
    Calculate Euclidian distance of two points in Euclidian space
    '''
    return round(math.sqrt((point1[0]-point2[0])**2 + (point1[1]-point2[1])**2), 2)

def curve_length(curve):
    '''
    Calculate curve length
    '''
    accLen = 0
    for idx in range(0, len(curve)-1):
        accLen += euclidian_dist(curve[idx], curve[idx+1])

    return accLen

    
def extend_point_on_line(point1, point2, dist):
    '''
    Return a new point, point3, which is on the same line generated by
    point1 and point2
    '''
    norm = round(dist / euclidian_dist(point1, point2), 2)
    newPointX = point2[0] + norm * (point1[0] - point2[0])
    newPointY = point2[1] + norm * (point1[1] - point2[1])

    return [newPointX, newPointY]

def subdivided_curve(curve, maxLen=0.05):
    '''
    Break up long segments in the input curve into smaller segments
    '''
    newCurve = []
    newCurve.append(curve[0])
    for idx in range(1, len(curve)):
        prevPoint = newCurve[-1]
        segLen = euclidian_dist(curve[idx], prevPoint)
        if(segLen > maxLen):
            numNewPoints = int(math.ceil(segLen / maxLen))
            newSegLen = round(segLen / numNewPoints, 2)
            for jdx in range(numNewPoints):
                newCurve.append(extend_point_on_line(
                    curve[idx],
                    prevPoint,
                    newSegLen*(jdx+1)))
        else:
            newCurve.append(curve[idx])

    return newCurve

def rotated_curve(curve, thetaRad):
    '''
    Args:
        curve: original curve
        theta: rotation angle
    Returns:
        rot_curve: rotated curve
    Descriptions:
        Rotate curve around the origin by theta
    '''
    rot_curve = []
    for idx in range(len(curve)):
        x_cord =  np.cos(thetaRad)*curve[idx][0] + np.sin(thetaRad)*curve[idx][1]
        y_cord = -np.sin(thetaRad)*curve[idx][0] + np.cos(thetaRad)*curve[idx][1]
        rot_curve.append([x_cord, y_cord])
    
    return rot_curve


def rebalanced_curve(curve, numPoints=50):
    '''
    Redraw the curve using "numPoints" points equally spaced along
    the length of the curve
    '''
    # Define output
    newCurve = []
    newCurve.append(curve[0])

    # Define parameters
    curveLen = curve_length(curve)
    segmentLen = curveLen / (numPoints - 1)
    remainingCurvePoints = curve[1:]

    # Processing
    for idx in range(numPoints-2):
        lastPoint = newCurve[-1]
        remainingDist = segmentLen
        pointFlag = False
        while(not pointFlag):
            nextPointDist = euclidian_dist(lastPoint, remainingCurvePoints[0])
            if(nextPointDist < remainingDist):
                remainingDist -= nextPointDist
                lastPoint = remainingCurvePoints[0]
                remainingCurvePoints = remainingCurvePoints[1:]
            else:
                nextPoint = extend_point_on_line(
                    lastPoint, remainingCurvePoints[0],
                    nextPointDist-remainingDist)
                newCurve.append(nextPoint)
                pointFlag = True
    newCurve.append(curve[-1])

    return newCurve
